dotnet ef database update --context BoschDbContext //gera uma nova migration com base nas diferenças entre suas classes de entidade e o banco de dados atual.
dotnet ef migrations add CreateInitialSchema --context BoschDbContext //Mesma coisa que o de cima, mas explicitando qual contexto usar, caso tenha mais de um DbContext no projeto.
dotnet ef migrations add InitialCreate //Esse comando aplica as migrations ao banco de dados real.



Criar uma nova migration com dotnet ef migrations add InitialCreate (ou nome que preferir)

Rodar dotnet ef database update pra aplicar e criar as tabelas no banco SQLite novo

// pra rodar na bosch eu usei sqlite entt esse é pra casa e para rodar no bdo
"ConnectionStrings": {
  "DefaultConnection": "Server=localhost;Database=boschDb;Trusted_Connection=True;TrustServerCertificate=True;"
  }


Ver todas as tabelas do banco
sqlite

.tables
Ver estrutura da tabela (exemplo: clientes)
sqlite
Copiar
Editar
.schema clientes
Selecionar dados da tabela
sqlite
Copiar
Editar
SELECT * FROM clientes;
Criar tabela (exemplo simples)
sqlite
Copiar
Editar
CREATE TABLE produtos (
  id INTEGER PRIMARY KEY,
  nome TEXT,
  preco REAL
);
Inserir dados
sqlite
Copiar
Editar
INSERT INTO produtos (nome, preco) VALUES ('Mouse', 50.00);
Deletar dados
sqlite
Copiar
Editar
DELETE FROM produtos WHERE id = 1;
Dropar tabela inteira
sqlite
Copiar
Editar
DROP TABLE produtos;
Pra sair do sqlite:

bash
Copiar
Editar
.exit
Quer que eu monte um mini roteiro de comandos pra você ir testando?

crud station ok

crud part ok